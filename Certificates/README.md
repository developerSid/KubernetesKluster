# Certs for the cluster

## Tools
1. [cfssl](https://cfssl.org)
   1. need `cfssl` and `cfssljson`

## Cert Generation for the Vagrant based steps
1. change directory to /Certificates/vagrant

### Create the certificate authority.
All the certificates and keys used throughout this setup will use the CA generated here as their base
1. If you choose to generate them yourself
   1. The basics of the following files can be generated by
      1. `cfssl print-defaults config > ca-config.json`
      1. `cfssl print-defaults config > ca-csr.json`
1. Otherwise
1. Generate you Certificate Authority (CA)
   1. `cd out`
   1. `cfssl gencert -initca ../in/ca-csr.json | cfssljson -bare ca -`
      * You should be able to use what is already in the _ca-config.json_, but you can always change it if you want
      1. Will result in
         * ca.csr - this is not used anywhere according to the etcd documentation
         * ca.pem
         * ca-key.pem

### Create the peer certificates using the newly created CA
1. Generate the encryption-config.yml for the API server
   1. `../in/encryption-config.sh`
1. Will need to update the _ca-csr.json_ with your locality's information
1. Generate peer certificates (I believe these steps can simply be expanded for however many hosts make up your control plane)
   1. If you decide to generate your own start with this and edit as necessary
      1. generate defaults
         * `cfssl print-defaults csr > kube-master01.vagrant.example-server.json.json`
         * `cfssl print-defaults csr > kube-master02.vagrant.example-server.json.json`
         * `cfssl print-defaults csr > kube-master03.vagrant.example-server.json.json`
      1. Note on sections
         1. *hosts* describes the list of host alternative names in the X509 certificate (I think)
         1. *keys* I'd recommend this
            ```json
            "key": {
                "algo": "rsa",
                "size": 2048
              }
            ```
   1. `cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=../in/ca-config.json -profile=peer ../in/kube-master01.vagrant.example-server.json | cfssljson -bare kube-master01.vagrant.example`
      1. Generates:
         * kube-master01.vagrant.example.csr
         * kube-master01.vagrant.example.pem
         * kube-master01.vagrant.example-key.pem
   1. `cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=../in/ca-config.json -profile=peer ../in/kube-master02.vagrant.example-server.json | cfssljson -bare kube-master02.vagrant.example`
      1. Generates:
         * kube-master02.vagrant.example.csr
         * kube-master02.vagrant.example.pem
         * kube-master02.vagrant.example-key.pem
   1. `cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=../in/ca-config.json -profile=peer ../in/kube-master03.vagrant.example-server.json | cfssljson -bare kube-master03.vagrant.example`
      1. Generates:
         * kube-master02.vagrant.example.csr
         * kube-master02.vagrant.example.pem
         * kube-master02.vagrant.example-key.pem
                 
### Create Kubernetes certificates and keys
1. Generate the Service Account Key Pair
   1. `cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=../in/ca-config.json -profile=kubernetes ../in/service-account-csr.json | cfssljson -bare service-account`
      1. Will Result in
         * service-account.csr
         * service-account.pem
         * service-account-key.pem
1. Generate the kube-controller-manager Key Pair
   1. `cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=../in/ca-config.json -profile=kubernetes ../in/kube-controller-manager-csr.json | cfssljson -bare kube-controller-manager`
      1. Will Result in
         * kube-controller-manager.csr
         * kube-controller-manager.pem
         * kube-controller-manager-key.pem
1. Generate the kube-scheduler Key Pair
   1. `cfssl gencert -ca=ca.pem  -ca-key=ca-key.pem  -config=../in/ca-config.json  -profile=kubernetes ../in/kube-scheduler-csr.json | cfssljson -bare kube-scheduler`
      1. Will Result in
         * kube-scheduler.csr
         * kube-scheduler.pem
         * kube-scheduler-key.pem
1. Generate the kube-proxy Key Pair
   1. `cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=../in/ca-config.json -profile=kubernetes ../in/kube-proxy-csr.json | cfssljson -bare kube-proxy`
      1. Will Result in
         * kube-proxy.csr
         * kube-proxy.pem
         * kube-proxy-key.pem
1. Generate the admin Key Pair
   1. `cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=../in/ca-config.json -profile=kubernetes ../in/admin-csr.json | cfssljson -bare admin`
      1. Will Result in
         * admin.csr
         * admin.pem
         * admin-key.pem

Notes:
1. [api server certs doc](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#x509-client-certs)
   * _If a client certificate is presented and verified, the common name of the subject is 
     used as the user name for the request_
     * The above means that each client cert generated for each kubelet running in the system will
       need to have a unique common name to help name the actual node.  This is must be why in
       Kubernetes the Hard Way certs are generated for each node.  Since the CA determines
       if a client is trusted or not.