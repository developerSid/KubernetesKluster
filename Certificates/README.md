# Certs for the cluster

## Tools
1. [cfssl](https://cfssl.org)
   1. need `cfssl` and `cfssljson`

## Cert Generation for the Vagrant based steps
1. change directory to /Certificates/vagrant

### Create the certificate authority.
All the certificates and keys used throughout this setup will use the CA generated here as their base
1. If you choose to generate them yourself
   1. The basics of the following files can be generated by
      1. `cfssl print-defaults config > ca-config.json`
      1. `cfssl print-defaults config > ca-csr.json`
1. Otherwise
1. Generate you Certificate Authority (CA)
   1. `cd out`
   1. `cfssl gencert -initca ../in/ca-csr.json | cfssljson -bare ca -`
      * You should be able to use what is already in the _ca-config.json_, but you can always change it if you want
      1. Will result in
         * ca.csr - this is not used anywhere according to the etcd documentation
         * ca.pem
         * ca-key.pem 
1. Will need to update the _ca-csr.json_ with your locality's information
1. Generate server certificates
   1. `cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=server server.json | cfssljson -bare server`
       1. Will Result in
          * server.csr
          * server.pem
          * server-key.pem

### Create the peer certificates using the newly created CA
1. Generate peer certificates (I believe these steps can simply be expanded for however many hosts make up your control plane)
   1. If you decide to generate your own start with this and edit as necessary
      1. generate defaults
         * `cfssl print-defaults csr > kube-master01.vagrant.example-server.json.json`
         * `cfssl print-defaults csr > kube-master02.vagrant.example-server.json.json`
         * `cfssl print-defaults csr > kube-master03.vagrant.example-server.json.json`
      1. Note on sections
         1. *hosts* describes the list of host alternative names in the X509 certificate (I think)
         1. *keys* I'd recommend this
            ```json
            "key": {
                "algo": "rsa",
                "size": 2048
              }
            ```
   1. `cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=../in/ca-config.json -profile=peer ../in/kube-master01.vagrant.example-server.json | cfssljson -bare kube-master01.vagrant.example`
      1. Generates:
         * kube-master01.vagrant.example.csr
         * kube-master01.vagrant.example.pem
         * kube-master01.vagrant.example-key.pem
   1. `cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=../in/ca-config.json -profile=peer ../in/kube-master02.vagrant.example-server.json | cfssljson -bare kube-master02.vagrant.example`
      1. Generates:
         * kube-master02.vagrant.example.csr
         * kube-master02.vagrant.example.pem
         * kube-master02.vagrant.example-key.pem
   1. `cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=../in/ca-config.json -profile=peer ../in/kube-master03.vagrant.example-server.json | cfssljson -bare kube-master03.vagrant.example`
      1. Generates:
         * kube-master02.vagrant.example.csr
         * kube-master02.vagrant.example.pem
         * kube-master02.vagrant.example-key.pem
                 
### Create Kubernetes certificates and keys
1. Generate the Service Account Key Pair
   1. `cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=../in/ca-config.json -profile=kubernetes ../in/service-account-csr.json | cfssljson -bare service-account`
      1. Will Result in
         * service-account.csr
         * service-account.pem
         * service-account-key.pem 

Notes:
1. [api server certs doc](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#x509-client-certs)
   * _If a client certificate is presented and verified, the common name of the subject is 
     used as the user name for the request_
     * The above means that each client cert generated for each kubelet running in the system will
       need to have a unique common name to help name the actual node.  This is must be why in
       Kubernetes the Hard Way certs are generated for each node.  Since the CA determines
       if a client is trusted or not.